/*!
 * Copyright (c) 2018 Omar Tawfik. All rights reserved. Licensed under the MIT License. See LICENSE file in the project root for license information.
 */

/// <summary>
/// This file is auto-generated by a build task. It shouldn't be edited by hand.
/// </summary>
import { LayoutInterop } from "./LayoutInterop";
import { MonacoInterop } from "./MonacoInterop";
import { TextDisplayInterop } from "./TextDisplayInterop";

export interface ILayoutInterop {
    initializeWebView(locale: string, title: string): Promise<void>;
    openExternalLink(url: string): Promise<void>;
    attachSideBarEvents(upButton: HTMLElement, scrollContentsArea: HTMLElement, downButton: HTMLElement): Promise<void>;
}

export interface IMonacoInterop {
    initialize(editorElement: HTMLElement, initialValue: string, isReadOnly: boolean): Promise<void>;
    dispose(): Promise<void>;
    selectRange(range: monaco.IRange): Promise<void>;
    saveToFile(): Promise<void>;
    openFile(confirmationMessage: string): Promise<void>;
    clearEditor(confirmationMessage: string): Promise<void>;
    cut(): Promise<void>;
    copy(): Promise<void>;
    paste(): Promise<void>;
    undo(): Promise<void>;
    redo(): Promise<void>;
}

export interface ITextDisplayInterop {
    initialize(textDisplayElement: HTMLElement): Promise<void>;
    dispose(): Promise<void>;
    scrollTo(element: HTMLElement): Promise<void>;
    setBackgroundColor(hexColor: string): Promise<void>;
}

declare global {
    export module JSInterop {
        export const Layout: ILayoutInterop;
        export const Monaco: IMonacoInterop;
        export const TextDisplay: ITextDisplayInterop;
    }
}

const layout: ILayoutInterop = new LayoutInterop();
const monaco: IMonacoInterop = new MonacoInterop();
const textDisplay: ITextDisplayInterop = new TextDisplayInterop();

(<any>global).JSInterop = {
    Layout: {
        initializeWebView: async (locale: string, title: string) : Promise<boolean> => {
            await layout.initializeWebView(locale, title);
            return true;
        },
        openExternalLink: async (url: string) : Promise<boolean> => {
            await layout.openExternalLink(url);
            return true;
        },
        attachSideBarEvents: async (upButton: HTMLElement, scrollContentsArea: HTMLElement, downButton: HTMLElement) : Promise<boolean> => {
            await layout.attachSideBarEvents(upButton, scrollContentsArea, downButton);
            return true;
        }
    },
    Monaco: {
        initialize: async (editorElement: HTMLElement, initialValue: string, isReadOnly: boolean) : Promise<boolean> => {
            await monaco.initialize(editorElement, initialValue, isReadOnly);
            return true;
        },
        dispose: async () : Promise<boolean> => {
            await monaco.dispose();
            return true;
        },
        selectRange: async (range: monaco.IRange) : Promise<boolean> => {
            await monaco.selectRange(range);
            return true;
        },
        saveToFile: async () : Promise<boolean> => {
            await monaco.saveToFile();
            return true;
        },
        openFile: async (confirmationMessage: string) : Promise<boolean> => {
            await monaco.openFile(confirmationMessage);
            return true;
        },
        clearEditor: async (confirmationMessage: string) : Promise<boolean> => {
            await monaco.clearEditor(confirmationMessage);
            return true;
        },
        cut: async () : Promise<boolean> => {
            await monaco.cut();
            return true;
        },
        copy: async () : Promise<boolean> => {
            await monaco.copy();
            return true;
        },
        paste: async () : Promise<boolean> => {
            await monaco.paste();
            return true;
        },
        undo: async () : Promise<boolean> => {
            await monaco.undo();
            return true;
        },
        redo: async () : Promise<boolean> => {
            await monaco.redo();
            return true;
        }
    },
    TextDisplay: {
        initialize: async (textDisplayElement: HTMLElement) : Promise<boolean> => {
            await textDisplay.initialize(textDisplayElement);
            return true;
        },
        dispose: async () : Promise<boolean> => {
            await textDisplay.dispose();
            return true;
        },
        scrollTo: async (element: HTMLElement) : Promise<boolean> => {
            await textDisplay.scrollTo(element);
            return true;
        },
        setBackgroundColor: async (hexColor: string) : Promise<boolean> => {
            await textDisplay.setBackgroundColor(hexColor);
            return true;
        }
    }
};
