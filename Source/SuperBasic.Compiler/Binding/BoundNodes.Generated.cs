// <copyright file="BoundNodes.Generated.cs" company="2018 Omar Tawfik">
// Copyright (c) 2018 Omar Tawfik. All rights reserved. Licensed under the MIT License. See LICENSE file in the project root for license information.
// </copyright>

/// <summary>
/// This file is auto-generated by a build task. It shouldn't be edited by hand.
/// </summary>
namespace SuperBasic.Compiler.Binding
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using SuperBasic.Compiler.Parsing;
    using SuperBasic.Compiler.Scanning;
    using SuperBasic.Utilities;

    internal sealed class BoundSubModule : BaseBoundNode
    {
        public BoundSubModule(SubModuleStatementSyntax syntax, string name, BoundStatementBlock body)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(name, null), "'name' must not be null.");
            Debug.Assert(!ReferenceEquals(body, null), "'body' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
            this.Body = body;
        }

        public SubModuleStatementSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Body;
            }
        }
    }

    internal abstract class BaseBoundStatement : BaseBoundNode
    {
    }

    internal sealed class BoundStatementBlock : BaseBoundStatement
    {
        public BoundStatementBlock(StatementBlockSyntax syntax, IReadOnlyList<BaseBoundStatement> body)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(body, null), "'body' must not be null.");

            this.Syntax = syntax;
            this.Body = body;
        }

        public StatementBlockSyntax Syntax { get; private set; }

        public IReadOnlyList<BaseBoundStatement> Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Body)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundIfPart : BaseBoundNode
    {
        public BoundIfPart(IfPartSyntax syntax, BaseBoundExpression expression, BoundStatementBlock body)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(body, null), "'body' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
            this.Body = body;
        }

        public IfPartSyntax Syntax { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundElseIfPart : BaseBoundNode
    {
        public BoundElseIfPart(ElseIfPartSyntax syntax, BaseBoundExpression expression, BoundStatementBlock body)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(body, null), "'body' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
            this.Body = body;
        }

        public ElseIfPartSyntax Syntax { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundElsePart : BaseBoundNode
    {
        public BoundElsePart(ElsePartSyntax syntax, BoundStatementBlock body)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(body, null), "'body' must not be null.");

            this.Syntax = syntax;
            this.Body = body;
        }

        public ElsePartSyntax Syntax { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundIfStatement : BaseBoundStatement
    {
        public BoundIfStatement(IfStatementSyntax syntax, BoundIfPart ifPart, IReadOnlyList<BoundElseIfPart> elseIfParts, BoundElsePart elsePartOpt)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(ifPart, null), "'ifPart' must not be null.");
            Debug.Assert(!ReferenceEquals(elseIfParts, null), "'elseIfParts' must not be null.");

            this.Syntax = syntax;
            this.IfPart = ifPart;
            this.ElseIfParts = elseIfParts;
            this.ElsePartOpt = elsePartOpt;
        }

        public IfStatementSyntax Syntax { get; private set; }

        public BoundIfPart IfPart { get; private set; }

        public IReadOnlyList<BoundElseIfPart> ElseIfParts { get; private set; }

        public BoundElsePart ElsePartOpt { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.IfPart;
                foreach (var child in this.ElseIfParts)
                {
                    yield return child;
                }

                if (!ReferenceEquals(this.ElsePartOpt, null))
                {
                    yield return this.ElsePartOpt;
                }
            }
        }
    }

    internal sealed class BoundWhileStatement : BaseBoundStatement
    {
        public BoundWhileStatement(WhileStatementSyntax syntax, BaseBoundExpression expression, BoundStatementBlock body)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(body, null), "'body' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
            this.Body = body;
        }

        public WhileStatementSyntax Syntax { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
                yield return this.Body;
            }
        }
    }

    internal sealed class BoundForStatement : BaseBoundStatement
    {
        public BoundForStatement(ForStatementSyntax syntax, string identifier, BaseBoundExpression fromExpression, BaseBoundExpression toExpression, BaseBoundExpression stepExpressionOpt, BoundStatementBlock body)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(identifier, null), "'identifier' must not be null.");
            Debug.Assert(!ReferenceEquals(fromExpression, null), "'fromExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(toExpression, null), "'toExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(body, null), "'body' must not be null.");

            this.Syntax = syntax;
            this.Identifier = identifier;
            this.FromExpression = fromExpression;
            this.ToExpression = toExpression;
            this.StepExpressionOpt = stepExpressionOpt;
            this.Body = body;
        }

        public ForStatementSyntax Syntax { get; private set; }

        public string Identifier { get; private set; }

        public BaseBoundExpression FromExpression { get; private set; }

        public BaseBoundExpression ToExpression { get; private set; }

        public BaseBoundExpression StepExpressionOpt { get; private set; }

        public BoundStatementBlock Body { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.FromExpression;
                yield return this.ToExpression;
                if (!ReferenceEquals(this.StepExpressionOpt, null))
                {
                    yield return this.StepExpressionOpt;
                }

                yield return this.Body;
            }
        }
    }

    internal sealed class BoundLabelStatement : BaseBoundStatement
    {
        public BoundLabelStatement(LabelStatementSyntax syntax, string label)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(label, null), "'label' must not be null.");

            this.Syntax = syntax;
            this.Label = label;
        }

        public LabelStatementSyntax Syntax { get; private set; }

        public string Label { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundGoToStatement : BaseBoundStatement
    {
        public BoundGoToStatement(GoToStatementSyntax syntax, string label)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(label, null), "'label' must not be null.");

            this.Syntax = syntax;
            this.Label = label;
        }

        public GoToStatementSyntax Syntax { get; private set; }

        public string Label { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundSubModuleInvocationStatement : BaseBoundStatement
    {
        public BoundSubModuleInvocationStatement(ExpressionStatementSyntax syntax, string subModule)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(subModule, null), "'subModule' must not be null.");

            this.Syntax = syntax;
            this.SubModule = subModule;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryMethodInvocationStatement : BaseBoundStatement
    {
        public BoundLibraryMethodInvocationStatement(ExpressionStatementSyntax syntax, string library, string method, IReadOnlyList<BaseBoundExpression> arguments)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(method, null), "'method' must not be null.");
            Debug.Assert(!ReferenceEquals(arguments, null), "'arguments' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Method = method;
            this.Arguments = arguments;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public string Method { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Arguments { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Arguments)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundVariableAssignmentStatement : BaseBoundStatement
    {
        public BoundVariableAssignmentStatement(ExpressionStatementSyntax syntax, string variable, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(variable, null), "'variable' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Variable = variable;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public string Variable { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundPropertyAssignmentStatement : BaseBoundStatement
    {
        public BoundPropertyAssignmentStatement(ExpressionStatementSyntax syntax, string library, string property, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(property, null), "'property' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Property = property;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public string Property { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundEventAssignmentStatement : BaseBoundStatement
    {
        public BoundEventAssignmentStatement(ExpressionStatementSyntax syntax, string library, string eventName, string subModule)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(eventName, null), "'eventName' must not be null.");
            Debug.Assert(!ReferenceEquals(subModule, null), "'subModule' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.EventName = eventName;
            this.SubModule = subModule;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public string EventName { get; private set; }

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundArrayAssignmentStatement : BaseBoundStatement
    {
        public BoundArrayAssignmentStatement(ExpressionStatementSyntax syntax, string array, IReadOnlyList<BaseBoundExpression> indices, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(array, null), "'array' must not be null.");
            Debug.Assert(!ReferenceEquals(indices, null), "'indices' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Array = array;
            this.Indices = indices;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public string Array { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Indices { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Indices)
                {
                    yield return child;
                }

                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundInvalidExpressionStatement : BaseBoundStatement
    {
        public BoundInvalidExpressionStatement(ExpressionStatementSyntax syntax, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
        }

        public ExpressionStatementSyntax Syntax { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal abstract class BaseBoundExpression : BaseBoundNode
    {
        public BaseBoundExpression(bool hasValue, bool hasErrors)
        {
            Debug.Assert(!ReferenceEquals(hasValue, null), "'hasValue' must not be null.");
            Debug.Assert(!ReferenceEquals(hasErrors, null), "'hasErrors' must not be null.");

            this.HasValue = hasValue;
            this.HasErrors = hasErrors;
        }

        public bool HasValue { get; private set; }

        public bool HasErrors { get; private set; }
    }

    internal sealed class BoundUnaryExpression : BaseBoundExpression
    {
        public BoundUnaryExpression(UnaryOperatorExpressionSyntax syntax, bool hasValue, bool hasErrors, TokenKind kind, BaseBoundExpression expression)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(kind, null), "'kind' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Kind = kind;
            this.Expression = expression;
        }

        public UnaryOperatorExpressionSyntax Syntax { get; private set; }

        public TokenKind Kind { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundBinaryExpression : BaseBoundExpression
    {
        public BoundBinaryExpression(BinaryOperatorExpressionSyntax syntax, bool hasValue, bool hasErrors, TokenKind kind, BaseBoundExpression left, BaseBoundExpression right)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(kind, null), "'kind' must not be null.");
            Debug.Assert(!ReferenceEquals(left, null), "'left' must not be null.");
            Debug.Assert(!ReferenceEquals(right, null), "'right' must not be null.");

            this.Syntax = syntax;
            this.Kind = kind;
            this.Left = left;
            this.Right = right;
        }

        public BinaryOperatorExpressionSyntax Syntax { get; private set; }

        public TokenKind Kind { get; private set; }

        public BaseBoundExpression Left { get; private set; }

        public BaseBoundExpression Right { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Left;
                yield return this.Right;
            }
        }
    }

    internal sealed class BoundArrayAccessExpression : BaseBoundExpression
    {
        public BoundArrayAccessExpression(ArrayAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, string array, IReadOnlyList<BaseBoundExpression> indices)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(array, null), "'array' must not be null.");
            Debug.Assert(!ReferenceEquals(indices, null), "'indices' must not be null.");

            this.Syntax = syntax;
            this.Array = array;
            this.Indices = indices;
        }

        public ArrayAccessExpressionSyntax Syntax { get; private set; }

        public string Array { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Indices { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Indices)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundLibraryTypeExpression : BaseBoundExpression
    {
        public BoundLibraryTypeExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string library)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
        }

        public IdentifierExpressionSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryMethodExpression : BaseBoundExpression
    {
        public BoundLibraryMethodExpression(ObjectAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, string library, string method)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(method, null), "'method' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Method = method;
        }

        public ObjectAccessExpressionSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public string Method { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryPropertyExpression : BaseBoundExpression
    {
        public BoundLibraryPropertyExpression(ObjectAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, string library, string property)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(property, null), "'property' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Property = property;
        }

        public ObjectAccessExpressionSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public string Property { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryEventExpression : BaseBoundExpression
    {
        public BoundLibraryEventExpression(ObjectAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, string library, string eventName)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(eventName, null), "'eventName' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.EventName = eventName;
        }

        public ObjectAccessExpressionSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public string EventName { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryMethodInvocationExpression : BaseBoundExpression
    {
        public BoundLibraryMethodInvocationExpression(InvocationExpressionSyntax syntax, bool hasValue, bool hasErrors, string library, string method, IReadOnlyList<BaseBoundExpression> arguments)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(method, null), "'method' must not be null.");
            Debug.Assert(!ReferenceEquals(arguments, null), "'arguments' must not be null.");

            this.Syntax = syntax;
            this.Library = library;
            this.Method = method;
            this.Arguments = arguments;
        }

        public InvocationExpressionSyntax Syntax { get; private set; }

        public string Library { get; private set; }

        public string Method { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Arguments { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Arguments)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundSubModuleExpression : BaseBoundExpression
    {
        public BoundSubModuleExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(name, null), "'name' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
        }

        public IdentifierExpressionSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundSubModuleInvocationExpression : BaseBoundExpression
    {
        public BoundSubModuleInvocationExpression(InvocationExpressionSyntax syntax, bool hasValue, bool hasErrors, string subModule)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(subModule, null), "'subModule' must not be null.");

            this.Syntax = syntax;
            this.SubModule = subModule;
        }

        public InvocationExpressionSyntax Syntax { get; private set; }

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundVariableExpression : BaseBoundExpression
    {
        public BoundVariableExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string name)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(name, null), "'name' must not be null.");

            this.Syntax = syntax;
            this.Name = name;
        }

        public IdentifierExpressionSyntax Syntax { get; private set; }

        public string Name { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundStringLiteralExpression : BaseBoundExpression
    {
        public BoundStringLiteralExpression(StringLiteralExpressionSyntax syntax, bool hasValue, bool hasErrors, string value)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(value, null), "'value' must not be null.");

            this.Syntax = syntax;
            this.Value = value;
        }

        public StringLiteralExpressionSyntax Syntax { get; private set; }

        public string Value { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundNumberLiteralExpression : BaseBoundExpression
    {
        public BoundNumberLiteralExpression(NumberLiteralExpressionSyntax syntax, bool hasValue, bool hasErrors, double value)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(value, null), "'value' must not be null.");

            this.Syntax = syntax;
            this.Value = value;
        }

        public NumberLiteralExpressionSyntax Syntax { get; private set; }

        public double Value { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundParenthesisExpression : BaseBoundExpression
    {
        public BoundParenthesisExpression(ParenthesisExpressionSyntax syntax, bool hasValue, bool hasErrors, BaseBoundExpression expression)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.Syntax = syntax;
            this.Expression = expression;
        }

        public ParenthesisExpressionSyntax Syntax { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundInvalidExpression : BaseBoundExpression
    {
        public BoundInvalidExpression(BaseExpressionSyntax syntax, bool hasValue, bool hasErrors)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");

            this.Syntax = syntax;
        }

        public BaseExpressionSyntax Syntax { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal abstract class BaseBoundNodeVisitor
    {
        public void Visit(BaseBoundNode node)
        {
            switch (node)
            {
                case BoundSubModule subModule:
                    this.VisitSubModule(subModule);
                    break;
                case BoundStatementBlock statementBlock:
                    this.VisitStatementBlock(statementBlock);
                    break;
                case BoundIfPart ifPart:
                    this.VisitIfPart(ifPart);
                    break;
                case BoundElseIfPart elseIfPart:
                    this.VisitElseIfPart(elseIfPart);
                    break;
                case BoundElsePart elsePart:
                    this.VisitElsePart(elsePart);
                    break;
                case BoundIfStatement ifStatement:
                    this.VisitIfStatement(ifStatement);
                    break;
                case BoundWhileStatement whileStatement:
                    this.VisitWhileStatement(whileStatement);
                    break;
                case BoundForStatement forStatement:
                    this.VisitForStatement(forStatement);
                    break;
                case BoundLabelStatement labelStatement:
                    this.VisitLabelStatement(labelStatement);
                    break;
                case BoundGoToStatement goToStatement:
                    this.VisitGoToStatement(goToStatement);
                    break;
                case BoundSubModuleInvocationStatement subModuleInvocationStatement:
                    this.VisitSubModuleInvocationStatement(subModuleInvocationStatement);
                    break;
                case BoundLibraryMethodInvocationStatement libraryMethodInvocationStatement:
                    this.VisitLibraryMethodInvocationStatement(libraryMethodInvocationStatement);
                    break;
                case BoundVariableAssignmentStatement variableAssignmentStatement:
                    this.VisitVariableAssignmentStatement(variableAssignmentStatement);
                    break;
                case BoundPropertyAssignmentStatement propertyAssignmentStatement:
                    this.VisitPropertyAssignmentStatement(propertyAssignmentStatement);
                    break;
                case BoundEventAssignmentStatement eventAssignmentStatement:
                    this.VisitEventAssignmentStatement(eventAssignmentStatement);
                    break;
                case BoundArrayAssignmentStatement arrayAssignmentStatement:
                    this.VisitArrayAssignmentStatement(arrayAssignmentStatement);
                    break;
                case BoundInvalidExpressionStatement invalidExpressionStatement:
                    this.VisitInvalidExpressionStatement(invalidExpressionStatement);
                    break;
                case BoundUnaryExpression unaryExpression:
                    this.VisitUnaryExpression(unaryExpression);
                    break;
                case BoundBinaryExpression binaryExpression:
                    this.VisitBinaryExpression(binaryExpression);
                    break;
                case BoundArrayAccessExpression arrayAccessExpression:
                    this.VisitArrayAccessExpression(arrayAccessExpression);
                    break;
                case BoundLibraryTypeExpression libraryTypeExpression:
                    this.VisitLibraryTypeExpression(libraryTypeExpression);
                    break;
                case BoundLibraryMethodExpression libraryMethodExpression:
                    this.VisitLibraryMethodExpression(libraryMethodExpression);
                    break;
                case BoundLibraryPropertyExpression libraryPropertyExpression:
                    this.VisitLibraryPropertyExpression(libraryPropertyExpression);
                    break;
                case BoundLibraryEventExpression libraryEventExpression:
                    this.VisitLibraryEventExpression(libraryEventExpression);
                    break;
                case BoundLibraryMethodInvocationExpression libraryMethodInvocationExpression:
                    this.VisitLibraryMethodInvocationExpression(libraryMethodInvocationExpression);
                    break;
                case BoundSubModuleExpression subModuleExpression:
                    this.VisitSubModuleExpression(subModuleExpression);
                    break;
                case BoundSubModuleInvocationExpression subModuleInvocationExpression:
                    this.VisitSubModuleInvocationExpression(subModuleInvocationExpression);
                    break;
                case BoundVariableExpression variableExpression:
                    this.VisitVariableExpression(variableExpression);
                    break;
                case BoundStringLiteralExpression stringLiteralExpression:
                    this.VisitStringLiteralExpression(stringLiteralExpression);
                    break;
                case BoundNumberLiteralExpression numberLiteralExpression:
                    this.VisitNumberLiteralExpression(numberLiteralExpression);
                    break;
                case BoundParenthesisExpression parenthesisExpression:
                    this.VisitParenthesisExpression(parenthesisExpression);
                    break;
                case BoundInvalidExpression invalidExpression:
                    this.VisitInvalidExpression(invalidExpression);
                    break;
                default:
                    throw ExceptionUtilities.UnexpectedValue(node);
            }
        }

        public virtual void VisitSubModule(BoundSubModule node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitStatementBlock(BoundStatementBlock node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitIfPart(BoundIfPart node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitElseIfPart(BoundElseIfPart node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitElsePart(BoundElsePart node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitIfStatement(BoundIfStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitWhileStatement(BoundWhileStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitForStatement(BoundForStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitLabelStatement(BoundLabelStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitGoToStatement(BoundGoToStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitSubModuleInvocationStatement(BoundSubModuleInvocationStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitLibraryMethodInvocationStatement(BoundLibraryMethodInvocationStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitVariableAssignmentStatement(BoundVariableAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitPropertyAssignmentStatement(BoundPropertyAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitEventAssignmentStatement(BoundEventAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitArrayAssignmentStatement(BoundArrayAssignmentStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitInvalidExpressionStatement(BoundInvalidExpressionStatement node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitUnaryExpression(BoundUnaryExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitBinaryExpression(BoundBinaryExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitArrayAccessExpression(BoundArrayAccessExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitLibraryTypeExpression(BoundLibraryTypeExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitLibraryMethodExpression(BoundLibraryMethodExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitLibraryPropertyExpression(BoundLibraryPropertyExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitLibraryEventExpression(BoundLibraryEventExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitLibraryMethodInvocationExpression(BoundLibraryMethodInvocationExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitSubModuleExpression(BoundSubModuleExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitSubModuleInvocationExpression(BoundSubModuleInvocationExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitVariableExpression(BoundVariableExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitStringLiteralExpression(BoundStringLiteralExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitNumberLiteralExpression(BoundNumberLiteralExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitParenthesisExpression(BoundParenthesisExpression node)
        {
            this.DefaultVisit(node);
        }

        public virtual void VisitInvalidExpression(BoundInvalidExpression node)
        {
            this.DefaultVisit(node);
        }

        private void DefaultVisit(BaseBoundNode node)
        {
            foreach (var child in node.Children)
            {
                this.Visit(child);
            }
        }
    }
}
