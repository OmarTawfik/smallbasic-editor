// <copyright file="BoundNodes.Generated.cs" company="2018 Omar Tawfik">
// Copyright (c) 2018 Omar Tawfik. All rights reserved. Licensed under the MIT License. See LICENSE file in the project root for license information.
// </copyright>

/// <summary>
/// This file is auto-generated by a build task. It shouldn't be edited by hand.
/// </summary>
namespace SuperBasic.Compiler.Binding
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using SuperBasic.Compiler.Parsing;
    using SuperBasic.Compiler.Scanning;

    internal abstract class BaseBoundStatement : BaseBoundNode
    {
    }

    internal sealed class BoundStatementBlock : BaseBoundStatement
    {
        private StatementBlockSyntax syntax;

        public BoundStatementBlock(StatementBlockSyntax syntax, IReadOnlyList<BaseBoundStatement> statements)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.syntax = syntax;
            this.Statements = statements;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public IReadOnlyList<BaseBoundStatement> Statements { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Statements)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundIfPart : BaseBoundNode
    {
        private IfPartSyntax syntax;

        public BoundIfPart(IfPartSyntax syntax, BaseBoundExpression expression, BoundStatementBlock statements)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.syntax = syntax;
            this.Expression = expression;
            this.Statements = statements;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public BaseBoundExpression Expression { get; private set; }

        public BoundStatementBlock Statements { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
                yield return this.Statements;
            }
        }
    }

    internal sealed class BoundElseIfPart : BaseBoundNode
    {
        private ElseIfPartSyntax syntax;

        public BoundElseIfPart(ElseIfPartSyntax syntax, BaseBoundExpression expression, BoundStatementBlock statements)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.syntax = syntax;
            this.Expression = expression;
            this.Statements = statements;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public BaseBoundExpression Expression { get; private set; }

        public BoundStatementBlock Statements { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
                yield return this.Statements;
            }
        }
    }

    internal sealed class BoundElsePart : BaseBoundNode
    {
        private ElsePartSyntax syntax;

        public BoundElsePart(ElsePartSyntax syntax, BoundStatementBlock statements)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.syntax = syntax;
            this.Statements = statements;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public BoundStatementBlock Statements { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Statements;
            }
        }
    }

    internal sealed class BoundIfStatement : BaseBoundStatement
    {
        private IfStatementSyntax syntax;

        public BoundIfStatement(IfStatementSyntax syntax, BoundIfPart ifPart, IReadOnlyList<BoundElseIfPart> elseIfParts, BoundElsePart elsePartOpt)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(ifPart, null), "'ifPart' must not be null.");
            Debug.Assert(!ReferenceEquals(elseIfParts, null), "'elseIfParts' must not be null.");

            this.syntax = syntax;
            this.IfPart = ifPart;
            this.ElseIfParts = elseIfParts;
            this.ElsePartOpt = elsePartOpt;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public BoundIfPart IfPart { get; private set; }

        public IReadOnlyList<BoundElseIfPart> ElseIfParts { get; private set; }

        public BoundElsePart ElsePartOpt { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.IfPart;
                foreach (var child in this.ElseIfParts)
                {
                    yield return child;
                }

                if (!ReferenceEquals(this.ElsePartOpt, null))
                {
                    yield return this.ElsePartOpt;
                }
            }
        }
    }

    internal sealed class BoundWhileStatement : BaseBoundStatement
    {
        private WhileStatementSyntax syntax;

        public BoundWhileStatement(WhileStatementSyntax syntax, BaseBoundExpression expression, BoundStatementBlock statements)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.syntax = syntax;
            this.Expression = expression;
            this.Statements = statements;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public BaseBoundExpression Expression { get; private set; }

        public BoundStatementBlock Statements { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
                yield return this.Statements;
            }
        }
    }

    internal sealed class BoundForStepClause : BaseBoundNode
    {
        private ForStepClauseSyntax syntax;

        public BoundForStepClause(ForStepClauseSyntax syntax, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.syntax = syntax;
            this.Expression = expression;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundForStatement : BaseBoundStatement
    {
        private ForStatementSyntax syntax;

        public BoundForStatement(ForStatementSyntax syntax, string identifier, BaseBoundExpression fromExpression, BaseBoundExpression toExpression, BoundForStepClause stepClauseOpt, BoundStatementBlock statements)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(identifier, null), "'identifier' must not be null.");
            Debug.Assert(!ReferenceEquals(fromExpression, null), "'fromExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(toExpression, null), "'toExpression' must not be null.");
            Debug.Assert(!ReferenceEquals(statements, null), "'statements' must not be null.");

            this.syntax = syntax;
            this.Identifier = identifier;
            this.FromExpression = fromExpression;
            this.ToExpression = toExpression;
            this.StepClauseOpt = stepClauseOpt;
            this.Statements = statements;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Identifier { get; private set; }

        public BaseBoundExpression FromExpression { get; private set; }

        public BaseBoundExpression ToExpression { get; private set; }

        public BoundForStepClause StepClauseOpt { get; private set; }

        public BoundStatementBlock Statements { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.FromExpression;
                yield return this.ToExpression;
                if (!ReferenceEquals(this.StepClauseOpt, null))
                {
                    yield return this.StepClauseOpt;
                }

                yield return this.Statements;
            }
        }
    }

    internal sealed class BoundLabelStatement : BaseBoundStatement
    {
        private LabelStatementSyntax syntax;

        public BoundLabelStatement(LabelStatementSyntax syntax, string label)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(label, null), "'label' must not be null.");

            this.syntax = syntax;
            this.Label = label;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Label { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundGoToStatement : BaseBoundStatement
    {
        private GoToStatementSyntax syntax;

        public BoundGoToStatement(GoToStatementSyntax syntax, string label)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(label, null), "'label' must not be null.");

            this.syntax = syntax;
            this.Label = label;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Label { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundSubModuleInvocationStatement : BaseBoundStatement
    {
        private InvocationExpressionSyntax syntax;

        public BoundSubModuleInvocationStatement(InvocationExpressionSyntax syntax, string subModule)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(subModule, null), "'subModule' must not be null.");

            this.syntax = syntax;
            this.SubModule = subModule;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryMethodInvocationStatement : BaseBoundStatement
    {
        private InvocationExpressionSyntax syntax;

        public BoundLibraryMethodInvocationStatement(InvocationExpressionSyntax syntax, string library, string method, IReadOnlyList<BaseBoundExpression> arguments)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(method, null), "'method' must not be null.");
            Debug.Assert(!ReferenceEquals(arguments, null), "'arguments' must not be null.");

            this.syntax = syntax;
            this.Library = library;
            this.Method = method;
            this.Arguments = arguments;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Library { get; private set; }

        public string Method { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Arguments { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Arguments)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundVariableAssignmentStatement : BaseBoundStatement
    {
        private BinaryOperatorExpressionSyntax syntax;

        public BoundVariableAssignmentStatement(BinaryOperatorExpressionSyntax syntax, string variable, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(variable, null), "'variable' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.syntax = syntax;
            this.Variable = variable;
            this.Expression = expression;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Variable { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundPropertyAssignmentStatement : BaseBoundStatement
    {
        private BinaryOperatorExpressionSyntax syntax;

        public BoundPropertyAssignmentStatement(BinaryOperatorExpressionSyntax syntax, string library, string property, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(property, null), "'property' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.syntax = syntax;
            this.Library = library;
            this.Property = property;
            this.Expression = expression;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Library { get; private set; }

        public string Property { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundEventAssignmentStatement : BaseBoundStatement
    {
        private BinaryOperatorExpressionSyntax syntax;

        public BoundEventAssignmentStatement(BinaryOperatorExpressionSyntax syntax, string library, string property, string subModule)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(property, null), "'property' must not be null.");
            Debug.Assert(!ReferenceEquals(subModule, null), "'subModule' must not be null.");

            this.syntax = syntax;
            this.Library = library;
            this.Property = property;
            this.SubModule = subModule;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Library { get; private set; }

        public string Property { get; private set; }

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundArrayAssignmentStatement : BaseBoundStatement
    {
        private BinaryOperatorExpressionSyntax syntax;

        public BoundArrayAssignmentStatement(BinaryOperatorExpressionSyntax syntax, string array, IReadOnlyList<BaseBoundExpression> indices, BaseBoundExpression expression)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(array, null), "'array' must not be null.");
            Debug.Assert(!ReferenceEquals(indices, null), "'indices' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.syntax = syntax;
            this.Array = array;
            this.Indices = indices;
            this.Expression = expression;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Array { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Indices { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Indices)
                {
                    yield return child;
                }

                yield return this.Expression;
            }
        }
    }

    internal abstract class BaseBoundExpression : BaseBoundNode
    {
        public BaseBoundExpression(bool hasValue, bool hasErrors)
        {
            Debug.Assert(!ReferenceEquals(hasValue, null), "'hasValue' must not be null.");
            Debug.Assert(!ReferenceEquals(hasErrors, null), "'hasErrors' must not be null.");

            this.HasValue = hasValue;
            this.HasErrors = hasErrors;
        }

        public bool HasValue { get; private set; }

        public bool HasErrors { get; private set; }
    }

    internal sealed class BoundUnaryExpression : BaseBoundExpression
    {
        private UnaryOperatorExpressionSyntax syntax;

        public BoundUnaryExpression(UnaryOperatorExpressionSyntax syntax, bool hasValue, bool hasErrors, TokenKind kind, BaseBoundExpression expression)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(kind, null), "'kind' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.syntax = syntax;
            this.Kind = kind;
            this.Expression = expression;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public TokenKind Kind { get; private set; }

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }

    internal sealed class BoundBinaryExpression : BaseBoundExpression
    {
        private BinaryOperatorExpressionSyntax syntax;

        public BoundBinaryExpression(BinaryOperatorExpressionSyntax syntax, bool hasValue, bool hasErrors, TokenKind kind, BaseBoundExpression left, BaseBoundExpression right)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(kind, null), "'kind' must not be null.");
            Debug.Assert(!ReferenceEquals(left, null), "'left' must not be null.");
            Debug.Assert(!ReferenceEquals(right, null), "'right' must not be null.");

            this.syntax = syntax;
            this.Kind = kind;
            this.Left = left;
            this.Right = right;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public TokenKind Kind { get; private set; }

        public BaseBoundExpression Left { get; private set; }

        public BaseBoundExpression Right { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Left;
                yield return this.Right;
            }
        }
    }

    internal sealed class BoundArrayAccessExpression : BaseBoundExpression
    {
        private ArrayAccessExpressionSyntax syntax;

        public BoundArrayAccessExpression(ArrayAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, string array, IReadOnlyList<BaseBoundExpression> indices)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(array, null), "'array' must not be null.");
            Debug.Assert(!ReferenceEquals(indices, null), "'indices' must not be null.");

            this.syntax = syntax;
            this.Array = array;
            this.Indices = indices;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Array { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Indices { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Indices)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundLibraryTypeExpression : BaseBoundExpression
    {
        private IdentifierExpressionSyntax syntax;

        public BoundLibraryTypeExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string library)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");

            this.syntax = syntax;
            this.Library = library;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Library { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryMemberExpression : BaseBoundExpression
    {
        private ObjectAccessExpressionSyntax syntax;

        public BoundLibraryMemberExpression(ObjectAccessExpressionSyntax syntax, bool hasValue, bool hasErrors, string library, string member)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(member, null), "'member' must not be null.");

            this.syntax = syntax;
            this.Library = library;
            this.Member = member;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Library { get; private set; }

        public string Member { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundLibraryMethodInvocationExpression : BaseBoundExpression
    {
        private InvocationExpressionSyntax syntax;

        public BoundLibraryMethodInvocationExpression(InvocationExpressionSyntax syntax, bool hasValue, bool hasErrors, string library, string method, IReadOnlyList<BaseBoundExpression> arguments)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(library, null), "'library' must not be null.");
            Debug.Assert(!ReferenceEquals(method, null), "'method' must not be null.");
            Debug.Assert(!ReferenceEquals(arguments, null), "'arguments' must not be null.");

            this.syntax = syntax;
            this.Library = library;
            this.Method = method;
            this.Arguments = arguments;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Library { get; private set; }

        public string Method { get; private set; }

        public IReadOnlyList<BaseBoundExpression> Arguments { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                foreach (var child in this.Arguments)
                {
                    yield return child;
                }
            }
        }
    }

    internal sealed class BoundSubModuleExpression : BaseBoundExpression
    {
        private IdentifierExpressionSyntax syntax;

        public BoundSubModuleExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string subModule)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(subModule, null), "'subModule' must not be null.");

            this.syntax = syntax;
            this.SubModule = subModule;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundSubModuleInvocationExpression : BaseBoundExpression
    {
        private InvocationExpressionSyntax syntax;

        public BoundSubModuleInvocationExpression(InvocationExpressionSyntax syntax, bool hasValue, bool hasErrors, string subModule)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(subModule, null), "'subModule' must not be null.");

            this.syntax = syntax;
            this.SubModule = subModule;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string SubModule { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundVariableExpression : BaseBoundExpression
    {
        private IdentifierExpressionSyntax syntax;

        public BoundVariableExpression(IdentifierExpressionSyntax syntax, bool hasValue, bool hasErrors, string variable)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(variable, null), "'variable' must not be null.");

            this.syntax = syntax;
            this.Variable = variable;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Variable { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundStringLiteralExpression : BaseBoundExpression
    {
        private StringLiteralExpressionSyntax syntax;

        public BoundStringLiteralExpression(StringLiteralExpressionSyntax syntax, bool hasValue, bool hasErrors, string value)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(value, null), "'value' must not be null.");

            this.syntax = syntax;
            this.Value = value;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public string Value { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundNumberLiteralExpression : BaseBoundExpression
    {
        private NumberLiteralExpressionSyntax syntax;

        public BoundNumberLiteralExpression(NumberLiteralExpressionSyntax syntax, bool hasValue, bool hasErrors, double value)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(value, null), "'value' must not be null.");

            this.syntax = syntax;
            this.Value = value;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public double Value { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                return Enumerable.Empty<BaseBoundNode>();
            }
        }
    }

    internal sealed class BoundParenthesisExpression : BaseBoundExpression
    {
        private ParenthesisExpressionSyntax syntax;

        public BoundParenthesisExpression(ParenthesisExpressionSyntax syntax, bool hasValue, bool hasErrors, BaseBoundExpression expression)
            : base(hasValue, hasErrors)
        {
            Debug.Assert(!ReferenceEquals(syntax, null), "'syntax' must not be null.");
            Debug.Assert(!ReferenceEquals(expression, null), "'expression' must not be null.");

            this.syntax = syntax;
            this.Expression = expression;
        }

        public override BaseSyntaxNode Syntax => this.syntax;

        public BaseBoundExpression Expression { get; private set; }

        public override IEnumerable<BaseBoundNode> Children
        {
            get
            {
                yield return this.Expression;
            }
        }
    }
}
